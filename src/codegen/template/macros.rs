//! "Template"s for Generating Macros
//!
//! This was pretty clean, and template like. Now I'm adding doc test generation
//! and it's getting messy.
use std::collections::HashSet;

use heck::ToSnakeCase;

use crate::codegen::{
    begin_crit, create_arg_string, emitln, end_crit, function,
    sarzak_maybe_get_one_r_sup_across_r14, template::types::emit_render_new, CachingContext,
    Result, SarzakModel,
};
use crate::sarzak::{AttributeName, Object, AS_IDENT, AS_RIDENT, AS_TYPE};

/// Template for the main body of a generated macro
///
/// In the calling code there are referrers and referents, and that affects
/// what goes where. Here we are just concerned with from -> to, within the
/// semantic context of the macro text itself, not in terms of the binary
/// relationship.
pub fn emit_binary_main(
    domain: &str,
    name: &str,
    from: &Object,
    to: &Object,
    number: u16,
    cond: bool,
    func_name: &str,
    inner: CachingContext,
    store: &SarzakModel,
    package: &str,
    doc_tests: bool,
    backwards: bool,
    many: bool,
) -> Result<CachingContext> {
    let mut context = CachingContext::new();

    emitln!(context, "");
    emitln!(
        context,
        "/// Macro to traverse [`{}`][ðŸ¦€] âž¡ [`{}`][ðŸ¦ž], via _R{}{}_",
        from.render(AS_TYPE),
        to.render(AS_TYPE),
        number,
        match cond {
            true => "(c)",
            false => "",
        }
    );
    emitln!(context, "///");
    let return_type = if cond {
        format!("an Option<&[`{}`][ðŸ¦ž]>", to.render(AS_TYPE))
    } else {
        format!("a &[`{}`][ðŸ¦ž]", to.render(AS_TYPE))
    };
    emitln!(
        context,
        "/// This macro expects a &[`{}`][ðŸ¦€], and returns {}.",
        from.render(AS_TYPE),
        return_type
    );
    emitln!(context, "///");
    emitln!(context, "/// Generated by `{}`", func_name);
    emitln!(context, "///");
    emitln!(
        context,
        "/// [ðŸ¦€]: crate::{}::types::{}",
        domain,
        from.render(AS_TYPE)
    );
    emitln!(
        context,
        "/// [ðŸ¦ž]: crate::{}::types::{}",
        domain,
        to.render(AS_TYPE)
    );

    if doc_tests {
        context.begin_ignore_block()?;
        context += create_binary_macro_test(
            from, to, store, domain, package, name, backwards, many, cond,
        )?;
        context.end_ignore_block()?;
    }

    emitln!(context, "#[macro_export]");

    begin_crit!(context, "{}-emit_binary_main", name)?;
    emitln!(context, "macro_rules! {} {{", name);

    context.increase_indent();
    emitln!(context, "($input:expr, $store:expr) => {{");

    // Insert the main body here
    context.increase_indent();
    context += inner;
    context.decrease_indent();

    emitln!(context, "}};");

    context.decrease_indent();
    emitln!(context, "}");

    // I'm not even sure what this does. The whole macro thing is confusing.
    // It this means we don't need ![macro_use] when we declare the macro module,
    // but I don't quite understand all the mechanics.
    emitln!(context, "pub use {};", name);
    end_crit!(context, "{}-emit_binary_main", name)?;

    Ok(context)
}

fn create_binary_macro_test(
    from: &Object,
    to: &Object,
    store: &SarzakModel,
    domain: &str,
    package: &str,
    macro_name: &str,
    backwards: bool,
    many: bool,
    cond: bool,
) -> Result<CachingContext> {
    let mut context = CachingContext::new();

    // We know that we need a from, and a to. The from is the argument to the
    // macro and the to is the result. The trick is figuring out where each
    // comes from, and how to get at it.
    // We can generate both a from and a to, and sort it out there. It's easier
    // than grabbing all the fields and relationship and inspecting them first.
    let mut from_use_statements = HashSet::new();
    let mut to_use_statements = HashSet::new();
    let (mut from_ctx, from_args) = emit_render_new(
        from,
        store,
        domain,
        package,
        &mut from_use_statements,
        false,
        false,
    )?;
    let (mut to_ctx, to_args) = emit_render_new(
        to,
        store,
        domain,
        package,
        &mut to_use_statements,
        false,
        false,
    )?;

    // Look in the from constructor's arguments and see if it contains a value
    // of the type we need as a "to".
    let in_from = from_args
        .iter()
        .filter_map(|a| {
            let symbol = from_ctx.exhume_symbol(a).unwrap();
            if symbol.value_type == to.render(AS_TYPE) {
                Some(())
            } else {
                None
            }
        })
        .collect::<Vec<()>>()
        .len()
        > 0;

    let in_to = to_args
        .iter()
        .filter_map(|a| {
            let symbol = to_ctx.exhume_symbol(a).unwrap();
            if symbol.value_type == from.render(AS_TYPE) {
                Some(())
            } else {
                None
            }
        })
        .collect::<Vec<()>>()
        .len()
        > 0;

    emitln!(context, "///");
    emitln!(context, "/// # Example");
    emitln!(context, "///");
    emitln!(context, "///```");

    // If from_args contains to-type, we are good to go. We will emit just the
    // from and be done with it.
    if in_from {
        for a in &from_args {
            let symbol = from_ctx.exhume_symbol(a).unwrap().clone();

            if symbol.value_type == to.render(AS_TYPE) {
                from_use_statements.insert(format!(
                    "use {}::{}::{};",
                    package,
                    domain,
                    from.render(AS_TYPE)
                ));

                for us in &from_use_statements {
                    emitln!(context, "/// # {}", us);
                }

                emitln!(context, "/// # use {}::{};", package, macro_name);
                emitln!(
                    context,
                    "/// # let mut store = {}::{}::ObjectStore::new();",
                    package,
                    domain.to_snake_case()
                );
                emitln!(context, "///");
                from_ctx.insert_prefix("/// ");
                context += from_ctx;
                emitln!(context, "///");

                // instantiate the from object
                emitln!(
                    context,
                    "/// let {} = {}::new(&mut store{});",
                    from.render(AS_IDENT),
                    from.render(AS_TYPE),
                    create_arg_string(&from_args, &context)
                );

                // invoke the macro
                emitln!(context, "///");
                let lhs = to.render(AS_RIDENT);
                emitln!(
                    context,
                    "/// let {} = {}!({}, store);",
                    lhs,
                    macro_name,
                    from.render(AS_IDENT)
                );

                emitln!(context, "/// assert_eq!(&{}, {});", symbol.value, lhs);

                break;
            }
        }
    } else if in_to {
        // Otherwise, we need to inspect to_args for the from-type. If it's there,
        // then just extract to, remember the name of the lhs, and be done with it.
        for a in &to_args {
            let symbol = to_ctx.exhume_symbol(a).unwrap().clone();

            // This always grabs the first one. If there are two, we won't know
            // which to use. In order to do that we'd need to know which
            // attribute goes with which relationship. Can we do that with what
            // we have now? Two passes again?
            //
            // This seems way too hard to tackle in this context.
            //
            // I think that we are missing model elements. Fixing the model will
            // make this sort of thing easier, I think. Need to cogitate.
            //
            if symbol.value_type == from.render(AS_TYPE) {
                from_use_statements.insert(format!(
                    "use {}::{}::{};",
                    package,
                    domain,
                    to.render(AS_TYPE)
                ));

                for us in &to_use_statements {
                    emitln!(context, "/// # {}", us);
                }

                emitln!(context, "/// # use {}::{};", package, macro_name);
                emitln!(
                    context,
                    "/// # let mut store = {}::{}::ObjectStore::new();",
                    package,
                    domain.to_snake_case()
                );
                emitln!(context, "///");
                to_ctx.insert_prefix("/// ");
                context += to_ctx;
                emitln!(context, "///");

                // Instantiate the to object
                emitln!(
                    context,
                    "/// let {} = {}::new(&mut store{});",
                    to.render(AS_IDENT),
                    to.render(AS_TYPE),
                    create_arg_string(&to_args, &context)
                );

                // Invoke the macro
                let lhs = to.render(AS_RIDENT);
                emitln!(
                    context,
                    "/// let {} = {}!({}, store);",
                    lhs,
                    macro_name,
                    symbol.value // from.render(AS_IDENT)
                );

                emitln!(context, "///");

                if many {
                    emitln!(
                        context,
                        "/// assert!({}.iter().find(|&x| **x == {}).is_some());",
                        lhs,
                        to.render(AS_IDENT)
                    );
                } else {
                    if cond {
                        emitln!(
                            context,
                            "/// assert_eq!(Some(&{}), {});",
                            to.render(AS_IDENT),
                            lhs
                        );
                    } else {
                        emitln!(
                            context,
                            "/// assert_eq!(&{}, {});",
                            to.render(AS_IDENT),
                            lhs
                        );
                    }
                }

                break;
            }
        }
    } else {
        // I'm wondering if we ever need to emit both?
        // Looks like yes...
        // And it's tricky. I actually think this happens only with bi-conditional
        // relationships, e.g., 1c-1c. The trick would be to identify the optional
        // parameters, and do one with and one without. Two tests.
        //
        // That's a big ask. When building the functions we default to None if there
        // is an optional parameter. We'd need to track
        //
        // Looks like I got it working, mid sentence.
        //
        for us in to_use_statements {
            from_use_statements.insert(us);
        }

        for us in &from_use_statements {
            emitln!(context, "/// # {}", us);
        }

        emitln!(context, "/// # use {}::{};", package, macro_name);
        emitln!(
            context,
            "/// # let mut store = {}::{}::ObjectStore::new();",
            package,
            domain.to_snake_case()
        );
        emitln!(context, "///");
        from_ctx.insert_prefix("/// ");
        context += from_ctx;

        to_ctx.insert_prefix("/// ");
        context += to_ctx;
        emitln!(context, "///");

        // We want the first one if to/referent is the Option being used in
        // the from/referrer constructor.
        // We want the second one given the reverse situation.
        // Some problem with the assert_eq below. It's fine as written in the
        // first case, but needs
        if !backwards {
            emitln!(
                context,
                "/// let {} = {}::new(&mut store{});",
                from.render(AS_IDENT),
                from.render(AS_TYPE),
                create_arg_string(&from_args, &context)
            );
        } else {
            emitln!(
                context,
                "/// let {} = {}::new(&mut store{});",
                to.render(AS_IDENT),
                to.render(AS_TYPE),
                create_arg_string(&to_args, &context)
            );
        }

        emitln!(context, "///");
        // Render the macro call
        let lhs = to.render(AS_RIDENT);
        emitln!(
            context,
            "/// let {} = {}!({}, store);",
            lhs,
            macro_name,
            from.render(AS_IDENT)
        );

        if many {
            emitln!(
                context,
                "/// assert!({}.iter().find(|&x| **x == {}).is_some());",
                lhs,
                to.render(AS_IDENT),
            );
        } else {
            emitln!(
                context,
                "/// assert_eq!(Some(&{}), {});",
                to.render(AS_IDENT),
                lhs
            );
        }
    }

    emitln!(context, "///```");

    Ok(context)
}

/// Template for generating an inner macro body
///
/// This one is meant for a many, unconditional implementation on the referrer
/// side.
pub fn emit_many_unconditional(to: &Object, ref_attr: &AttributeName) -> CachingContext {
    let mut context = CachingContext::new();

    let _ = begin_crit!(context, "{}-emit_many_unconditional", to.render(AS_IDENT));
    emitln!(context, "// {}", function!());
    emitln!(context, "let mut result = Vec::new();");
    emitln!(context, "for z in &$input.{} {{", ref_attr.render(AS_IDENT));
    context.increase_indent();
    emitln!(
        context,
        "let {} = $store.exhume_{}(&z).unwrap();",
        ref_attr.render(AS_IDENT),
        to.render(AS_IDENT)
    );
    emitln!(context, "result.push({});", ref_attr.render(AS_IDENT));
    context.decrease_indent();
    emitln!(context, "}");
    emitln!(context, "result");
    let _ = end_crit!(context, "{}-emit_many_unconditional", to.render(AS_IDENT));

    context
}

/// Template for generating an inner macro body
///
/// This one is meant for a many, conditional implementation on the referrer
/// side.
pub fn emit_many_conditional(to: &Object, ref_attr: &AttributeName) -> CachingContext {
    let mut context = CachingContext::new();

    let _ = begin_crit!(context, "{}-emit_many_conditional", to.render(AS_IDENT));
    emitln!(context, "// {}", function!());
    emitln!(context, "let mut result = Vec::new();");
    emitln!(context, "for z in &$input.{} {{", ref_attr.render(AS_IDENT));
    context.increase_indent();
    emitln!(
        context,
        "let {} = $store.exhume_{}(&z).unwrap();",
        ref_attr.render(AS_IDENT),
        to.render(AS_IDENT)
    );
    emitln!(context, "result.push({});", ref_attr.render(AS_IDENT));
    context.decrease_indent();
    emitln!(context, "}");
    emitln!(context, "result");
    let _ = end_crit!(context, "{}-emit_many_conditional", to.render(AS_IDENT));

    context
}

/// Template for generating inner macro body
///
/// This template is used when the input is 1(c), and the output is an [`Option`].
pub fn emit_one_conditional(to: &Object, ref_attr: &AttributeName) -> CachingContext {
    let mut context = CachingContext::new();

    let _ = begin_crit!(context, "{}-emit_one_conditional", to.render(AS_IDENT));
    emitln!(context, "// {}", function!());
    emitln!(context, "match &$input.{} {{", ref_attr.render(AS_IDENT));
    context.increase_indent();
    emitln!(
        context,
        "Some(i) => $store.exhume_{}(i),",
        to.render(AS_IDENT)
    );
    emitln!(context, "None => None,");
    context.decrease_indent();
    emitln!(context, "}");
    context.decrease_indent();
    let _ = end_crit!(context, "{}-emit_one_conditional", to.render(AS_IDENT));

    context
}

pub fn emit_one_unconditional(to: &Object, ref_attr: &AttributeName) -> CachingContext {
    let mut context = CachingContext::new();

    let _ = begin_crit!(context, "{}-emit_one_unconditional", to.render(AS_IDENT));
    emitln!(context, "// {}", function!());
    emitln!(
        context,
        "$store.exhume_{}(&$input.{}).unwrap()",
        to.render(AS_IDENT),
        ref_attr.render(AS_IDENT)
    );
    context.decrease_indent();
    let _ = end_crit!(context, "{}-emit_one_unconditional", to.render(AS_IDENT));

    context
}

/// Template for generating a traversal across a 1-1 relationship where the
/// referential attribute is on the opposite side of the the traversal.
pub fn emit_one_unconditional_lookup(
    store: &SarzakModel,
    to: &Object,
    from: &Object,
    ref_attr: &AttributeName,
) -> CachingContext {
    let mut context = CachingContext::new();

    let _ = context.begin_critical_block(format!(
        "{}-{}-emit_one_unconditional_lookup",
        from.render(AS_IDENT),
        to.render(AS_IDENT)
    ));
    emitln!(context, "// {}", function!());
    emitln!(context, "$store");
    context.increase_indent();
    emitln!(context, ".iter_{}()", to.render(AS_IDENT));

    let id = if sarzak_maybe_get_one_r_sup_across_r14!(from, store).is_some() {
        "get_id()"
    } else {
        "id"
    };

    emitln!(
        context,
        ".find(|z| z.1.{} == $input.{})",
        ref_attr.render(AS_IDENT),
        id
    );
    emitln!(context, ".map(|z| z.1)");
    emitln!(context, ".unwrap()");
    context.decrease_indent();

    let _ = context.end_critical_block(format!(
        "{}-{}-emit_one_unconditional_lookup",
        from.render(AS_IDENT),
        to.render(AS_IDENT)
    ));

    context
}

/// Template for generating a traversal across a 1(c)-1 relationship where the
/// referential attribute is on the opposite side of the the traversal.
///
/// Damn. We need to check the from side to see if it's an enum, which don't have
/// an id field. This is a pain in the ass. I wonder if doing Isa would be better
/// like:
/// struct FooIsa {
///     id: Uuid,
///     isa: enum
/// }
pub fn emit_one_conditional_lookup(
    store: &SarzakModel,
    to: &Object,
    from: &Object,
    ref_attr: &AttributeName,
    is_option: bool,
) -> CachingContext {
    let mut context = CachingContext::new();

    let _ = context.begin_critical_block(format!(
        "{}-{}-emit_one_conditional_lookup",
        from.render(AS_IDENT),
        to.render(AS_IDENT)
    ));
    emitln!(context, "// {}", function!());
    emitln!(context, "$store");
    context.increase_indent();
    emitln!(context, ".iter_{}()", to.render(AS_IDENT));

    let id = if sarzak_maybe_get_one_r_sup_across_r14!(from, store).is_some() {
        "get_id()"
    } else {
        "id"
    };

    let input_id = if is_option {
        format!("Some($input.{})", id)
    } else {
        format!("$input.{}", id)
    };

    emitln!(
        context,
        // â—ï¸This needs to be Some($input.id) when the from side, which is the referrer,
        // since this is a lookup, has an Optional pointer.
        // Shit. I can't tell if this is old or new. I really need to clean up.
        ".find(|z| z.1.{} == {})",
        ref_attr.render(AS_IDENT),
        input_id
    );
    emitln!(context, ".map(|(_, z)| z)");
    context.decrease_indent();

    let _ = context.end_critical_block(format!(
        "{}-{}-emit_one_conditional_lookup",
        from.render(AS_IDENT),
        to.render(AS_IDENT)
    ));

    context
}

/// Template for generating an inner macro body
///
/// This one is meant for a many, unconditional implementation on the referent
/// side.
pub fn emit_many_conditional_lookup(
    store: &SarzakModel,
    to: &Object,
    from: &Object,
    ref_attr: &AttributeName,
    is_option: bool,
) -> CachingContext {
    let mut context = CachingContext::new();

    let _ = context.begin_critical_block(format!(
        "{}-{}-emit_many_conditional_lookup",
        from.render(AS_IDENT),
        to.render(AS_IDENT)
    ));
    emitln!(context, "// {}", function!());
    emitln!(context, "$store");
    context.increase_indent();
    emitln!(context, ".iter_{}()", to.render(AS_IDENT));

    let id = if sarzak_maybe_get_one_r_sup_across_r14!(from, store).is_some() {
        "get_id()"
    } else {
        "id"
    };

    let input_id = if is_option {
        format!("Some($input.{})", id)
    } else {
        format!("$input.{}", id)
    };

    emitln!(
        context,
        ".filter_map(|z| if z.1.{} == {} {{ Some(z.1) }} else {{ None }})",
        ref_attr.render(AS_IDENT),
        input_id
    );
    emitln!(context, ".collect::<Vec<&{}>>()", to.render(AS_TYPE));
    context.decrease_indent();

    let _ = context.end_critical_block(format!(
        "{}-{}-emit_many_conditional_lookup",
        from.render(AS_IDENT),
        to.render(AS_IDENT)
    ));

    context
}

/// Template for the main body of an associative macro
///
/// In the calling code there are referrers and referents, and that affects
/// what goes where. Here we are just concerned with from -> to, within the
/// semantic context of the macro text itself, not in terms of the binary
/// relationship.
pub fn emit_associative_main(
    domain: &str,
    name: &str,
    from: &Object,
    to: &Object,
    ass: &Object,
    number: u16,
    func_name: &str,
    inner: CachingContext,
    store: &SarzakModel,
    package: &str,
    doc_tests: bool,
    cond: bool,
    many: bool,
) -> Result<CachingContext> {
    let mut context = CachingContext::new();

    emitln!(context, "");
    emitln!(
        context,
        "/// Macro to traverse [`{}`][ðŸ¦€] âž¡ [`{}`][ðŸ¦ž], across [`{}`][ðŸ¦‘] via _R{}_",
        from.render(AS_TYPE),
        to.render(AS_TYPE),
        ass.render(AS_TYPE),
        number
    );
    emitln!(context, "///");
    // let return_type = if cond {
    //     format!("an Option<&[`{}`][ðŸ¦ž]>", to.render(AS_TYPE))
    // } else {
    let return_type = format!("a &[`{}`][ðŸ¦ž]", to.render(AS_TYPE));
    // };
    emitln!(
        context,
        "/// This macro expects a &[`{}`][ðŸ¦€], and returns {}.",
        from.render(AS_TYPE),
        return_type
    );
    emitln!(context, "///");
    emitln!(context, "/// Generated by `{}`", func_name);
    emitln!(context, "///");
    emitln!(
        context,
        "/// [ðŸ¦€]: crate::{}::types::{}",
        domain,
        from.render(AS_TYPE)
    );
    emitln!(
        context,
        "/// [ðŸ¦ž]: crate::{}::types::{}",
        domain,
        to.render(AS_TYPE)
    );
    emitln!(
        context,
        "/// [ðŸ¦‘]: crate::{}::types::{}",
        domain,
        ass.render(AS_TYPE)
    );

    if doc_tests {
        let _ = context.begin_ignore_block();
        context +=
            create_associative_macro_test(to, ass, store, domain, package, name, cond, many)?;
        let _ = context.end_ignore_block();
    }

    emitln!(context, "#[macro_export]");

    begin_crit!(context, "{}-emit_associative_main", name)?;
    emitln!(context, "macro_rules! {} {{", name);

    context.increase_indent();
    emitln!(context, "($input:expr, $store:expr) => {{");

    // Insert the main body here
    context.increase_indent();
    context += inner;
    context.decrease_indent();

    emitln!(context, "}};");

    context.decrease_indent();
    emitln!(context, "}");

    // I'm not even sure what this does. The whole macro thing is confusing.
    // It this means we don't need ![macro_use] when we declare the macro module,
    // but I don't quite understand all the mechanics.
    emitln!(context, "pub use {};", name);
    end_crit!(context, "{}-emit_associative_main", name)?;

    Ok(context)
}

fn create_associative_macro_test(
    to: &Object,
    assoc: &Object,
    store: &SarzakModel,
    domain: &str,
    package: &str,
    macro_name: &str,
    cond: bool,
    many: bool,
) -> Result<CachingContext> {
    let mut context = CachingContext::new();

    let mut use_statements = HashSet::new();
    let (mut ctx, args) = emit_render_new(
        assoc,
        store,
        domain,
        package,
        &mut use_statements,
        false,
        false,
    )?;

    emitln!(context, "///");
    emitln!(context, "/// # Example");
    emitln!(context, "///");
    emitln!(context, "///```");

    for us in &use_statements {
        emitln!(context, "/// # {}", us);
    }

    emitln!(context, "/// # use {}::{};", package, macro_name);
    emitln!(
        context,
        "/// # let mut store = {}::{}::ObjectStore::new();",
        package,
        domain.to_snake_case()
    );
    emitln!(context, "///");
    ctx.insert_prefix("/// ");
    context += ctx;

    emitln!(
        context,
        "/// let {} = {}::new(&mut store{});",
        assoc.render(AS_IDENT),
        assoc.render(AS_TYPE),
        create_arg_string(&args, &context)
    );

    let cheat = context.exhume_symbol(&args[0]).unwrap().clone();
    let hack = context.exhume_symbol(&args[1]).unwrap().clone();

    emitln!(context, "///");

    let lhs = to.render(AS_RIDENT);
    let lhs_type = to.render(AS_TYPE);

    emitln!(
        context,
        "/// let {} = {}!({}, store);",
        lhs,
        macro_name,
        if lhs_type == cheat.value_type {
            &hack.value
        } else {
            &cheat.value
        }
    );

    if many {
        let value = if lhs_type == cheat.value_type {
            cheat.value
        } else {
            hack.value
        };

        emitln!(
            context,
            "/// assert!({}.iter().find(|&x| **x == {}).is_some());",
            lhs,
            value
        );
    } else {
        if cond {
            emitln!(context, "/// assert_eq!(Some(&{}), {});", hack.value, lhs);
        } else {
            emitln!(context, "/// assert_eq!(&{}, {});", cheat.value, lhs);
        }
    }

    emitln!(context, "///```");

    Ok(context)
}

/// Emit Template for generating associative macro
///
pub fn emit_assoc_many(
    to: &Object,
    to_ref: &AttributeName,
    from_ref: &AttributeName,
    assoc_obj: &Object,
) -> CachingContext {
    let mut context = CachingContext::new();

    emitln!(context, "// {}", function!());
    emitln!(context, "$store");
    context.increase_indent();
    emitln!(context, ".iter_{}()", assoc_obj.render(AS_IDENT));
    emitln!(
        context,
        ".filter(|a| a.1.{} == $input.id)",
        from_ref.render(AS_IDENT)
    );
    emitln!(
        context,
        ".map(|a| $store.exhume_{}(&a.1.{}).unwrap())",
        to.render(AS_IDENT),
        to_ref.render(AS_IDENT)
    );
    emitln!(context, ".collect::<Vec<&{}>>()", to.render(AS_TYPE));

    context
}

/// Emit Template for generating associative macro
///
pub fn emit_assoc_maybe_get_one(
    to: &Object,
    to_ref: &AttributeName,
    from_ref: &AttributeName,
    assoc_obj: &Object,
) -> CachingContext {
    let mut context = CachingContext::new();

    emitln!(context, "// {}", function!());
    emitln!(context, "$store");
    context.increase_indent();
    emitln!(context, ".iter_{}()", assoc_obj.render(AS_IDENT));
    emitln!(
        context,
        ".filter(|a| a.1.{} == $input.id)",
        from_ref.render(AS_IDENT)
    );
    emitln!(context, ".next()");
    emitln!(
        context,
        ".and_then(|a| $store.exhume_{}(&a.1.{}))",
        to.render(AS_IDENT),
        to_ref.render(AS_IDENT)
    );

    context
}
