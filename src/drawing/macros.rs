//! Macros for navigation the Drawing domain
//!
//! Generated Code -- do not edit
//! Use the following invocation to reproduce.
//! ```ignore
//!  target/debug/gen_macro_drawing models/drawing_2.json src/drawing/macros.rs
//! ```

/// Macro to traverse IsaUI ➡ Anchor, via R9
///
/// This macro expects an `impl Iterator<Item=(&Uuid, &IsaUI)>`, and returns a `Vec<(&Uuid, &Anchor)>`.
///
/// Generated by `generate_binary_macro_referrer_to_referent`
#[macro_export]
macro_rules! get_a_across_r9 {
    ($input:expr, $store:expr) => {{
        $input
            .iter()
            .map(|(_, z)| {
                let from = $store.drawing.exhume_from(&z.from).unwrap();
                (&from.id, from)
            })
            .collect::<Vec<(&Uuid, &Anchor)>>()
    }};
}

/// Macro to traverse Anchor ➡ IsaUI, via R9
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &Anchor)>`, and returns a `Vec<(&Uuid, &IsaUI)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_iui_across_r9 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.drawing.iter_isaui() {
                if z.from == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }};
}

/// Macro to traverse IsaUI ➡ Isa, via R11
///
/// This macro expects an `impl Iterator<Item=(&Uuid, &IsaUI)>`, and returns a `Vec<(&Uuid, &Isa)>`.
///
/// Generated by `generate_binary_macro_referrer_to_referent`
#[macro_export]
macro_rules! get_r_isa_across_r11 {
    ($input:expr, $store:expr) => {{
        $input
            .iter()
            .map(|(_, z)| {
                let isa = $store.sarzak.exhume_isa(&z.isa).unwrap();
                (&isa.id, isa)
            })
            .collect::<Vec<(&Uuid, &Isa)>>()
    }};
}

/// Macro to traverse Isa ➡ IsaUI, via R11
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &Isa)>`, and returns a `Vec<(&Uuid, &IsaUI)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_iui_across_r11 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.drawing.iter_isa_ui() {
                if z.isa == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }};
}

/// Macro to traverse Object ➡ ObjectUI, via R1
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &Object)>`, and returns a `Vec<(&Uuid, &ObjectUI)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_oui_across_r1 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.drawing.iter_object_ui() {
                if z.object == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }};
}

/// Macro to traverse ObjectUI ➡ Point, via R13
///
/// This macro expects an `impl Iterator<Item=(&Uuid, &ObjectUI)>`, and returns a `Vec<(&Uuid, &Point)>`.
///
/// Generated by `generate_binary_macro_referrer_to_referent`
#[macro_export]
macro_rules! get_p_across_r13 {
    ($input:expr, $store:expr) => {{
        $input
            .iter()
            .map(|(_, z)| {
                let origin = $store.drawing.exhume_origin(&z.origin).unwrap();
                (&origin.id, origin)
            })
            .collect::<Vec<(&Uuid, &Point)>>()
    }};
}

/// Macro to traverse Point ➡ ObjectUI, via R13
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &Point)>`, and returns a `Vec<(&Uuid, &ObjectUI)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_oui_across_r13 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.drawing.iter_objectui() {
                if z.origin == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }};
}

/// Macro to traverse Anchor ➡ Point, via R4
///
/// This macro expects an `impl Iterator<Item=(&Uuid, &Anchor)>`, and returns a `Vec<(&Uuid, &Point)>`.
///
/// Generated by `generate_binary_macro_referrer_to_referent`
#[macro_export]
macro_rules! get_p_across_r4 {
    ($input:expr, $store:expr) => {{
        $input
            .iter()
            .map(|(_, z)| {
                let location = $store.drawing.exhume_location(&z.location).unwrap();
                (&location.id, location)
            })
            .collect::<Vec<(&Uuid, &Point)>>()
    }};
}

/// Macro to traverse Point ➡ Anchor, via R4
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &Point)>`, and returns a `Vec<(&Uuid, &Anchor)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_a_across_r4 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.drawing.iter_anchor() {
                if z.location == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }};
}

/// Macro to traverse ObjectUI ➡ Edge, via R14
///
/// This macro expects an `impl Iterator<Item=(&Uuid, &ObjectUI)>`, and returns a `Vec<(&Uuid, &Edge)>`.
///
/// Generated by `generate_binary_macro_referrer_to_referent`
#[macro_export]
macro_rules! get_e_across_r14 {
    ($input:expr, $store:expr) => {{
        $input
            .iter()
            .map(|(_, z)| {
                let edges = $store.drawing.exhume_edges(&z.edges).unwrap();
                (&edges.id, edges)
            })
            .collect::<Vec<(&Uuid, &Edge)>>()
    }};
}

/// Macro to traverse Edge ➡ ObjectUI, via R14
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &Edge)>`, and returns a `Vec<(&Uuid, &ObjectUI)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_oui_across_r14 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.drawing.iter_objectui() {
                if z.edges == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }};
}

/// Macro to traverse IsaUI ➡ Anchor, via R10
///
/// This macro expects an `impl Iterator<Item=(&Uuid, &IsaUI)>`, and returns a `Vec<(&Uuid, &Anchor)>`.
///
/// Generated by `generate_binary_macro_referrer_to_referent`
#[macro_export]
macro_rules! get_a_across_r10 {
    ($input:expr, $store:expr) => {{
        $input
            .iter()
            .map(|(_, z)| {
                let to = $store.drawing.exhume_to(&z.to).unwrap();
                (&to.id, to)
            })
            .collect::<Vec<(&Uuid, &Anchor)>>()
    }};
}

/// Macro to traverse Anchor ➡ IsaUI, via R10
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &Anchor)>`, and returns a `Vec<(&Uuid, &IsaUI)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_iui_across_r10 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.drawing.iter_isaui() {
                if z.to == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }};
}

/// Macro to traverse Anchor ➡ Edge, via R3
///
/// This macro expects an `impl Iterator<Item=(&Uuid, &Anchor)>`, and returns a `Vec<(&Uuid, &Edge)>`.
///
/// Generated by `generate_binary_macro_referrer_to_referent`
#[macro_export]
macro_rules! get_e_across_r3 {
    ($input:expr, $store:expr) => {{
        $input
            .iter()
            .map(|(_, z)| {
                let edge = $store.drawing.exhume_edge(&z.edge).unwrap();
                (&edge.id, edge)
            })
            .collect::<Vec<(&Uuid, &Edge)>>()
    }};
}

/// Macro to traverse Edge ➡ Anchor, via R3
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &Edge)>`, and returns a `Vec<(&Uuid, &Anchor)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_a_across_r3 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.drawing.iter_anchor() {
                if z.edge == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }};
}

/// Macro to traverse Anchor ➡ Point, via R5
///
/// This macro expects an `impl Iterator<Item=(&Uuid, &Anchor)>`, and returns a `Vec<(&Uuid, &Point)>`.
///
/// Generated by `generate_binary_macro_referrer_to_referent`
#[macro_export]
macro_rules! get_p_across_r5 {
    ($input:expr, $store:expr) => {{
        $input
            .iter()
            .map(|(_, z)| {
                let offset = $store.drawing.exhume_offset(&z.offset).unwrap();
                (&offset.id, offset)
            })
            .collect::<Vec<(&Uuid, &Point)>>()
    }};
}

/// Macro to traverse Point ➡ Anchor, via R5
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &Point)>`, and returns a `Vec<(&Uuid, &Anchor)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_a_across_r5 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.drawing.iter_anchor() {
                if z.offset == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }};
}

/// Macro to traverse BinaryUI ➡ Binary, via R12
///
/// This macro expects an `impl Iterator<Item=(&Uuid, &BinaryUI)>`, and returns a `Vec<(&Uuid, &Binary)>`.
///
/// Generated by `generate_binary_macro_referrer_to_referent`
#[macro_export]
macro_rules! get_r_bin_across_r12 {
    ($input:expr, $store:expr) => {{
        $input
            .iter()
            .map(|(_, z)| {
                let binary = $store.sarzak.exhume_binary(&z.binary).unwrap();
                (&binary.id, binary)
            })
            .collect::<Vec<(&Uuid, &Binary)>>()
    }};
}

/// Macro to traverse Binary ➡ BinaryUI, via R12
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &Binary)>`, and returns a `Vec<(&Uuid, &BinaryUI)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_bui_across_r12 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.drawing.iter_binaryui() {
                if z.binary == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }};
}

/// Macro to traverse BinaryUI ➡ Anchor, via R8
///
/// This macro expects an `impl Iterator<Item=(&Uuid, &BinaryUI)>`, and returns a `Vec<(&Uuid, &Anchor)>`.
///
/// Generated by `generate_binary_macro_referrer_to_referent`
#[macro_export]
macro_rules! get_a_across_r8 {
    ($input:expr, $store:expr) => {{
        $input
            .iter()
            .map(|(_, z)| {
                let to = $store.drawing.exhume_to(&z.to).unwrap();
                (&to.id, to)
            })
            .collect::<Vec<(&Uuid, &Anchor)>>()
    }};
}

/// Macro to traverse Anchor ➡ BinaryUI, via R8
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &Anchor)>`, and returns a `Vec<(&Uuid, &BinaryUI)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_bui_across_r8 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.drawing.iter_binary_ui() {
                if z.to == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }};
}

/// Macro to traverse BinaryUI ➡ Anchor, via R7
///
/// This macro expects an `impl Iterator<Item=(&Uuid, &BinaryUI)>`, and returns a `Vec<(&Uuid, &Anchor)>`.
///
/// Generated by `generate_binary_macro_referrer_to_referent`
#[macro_export]
macro_rules! get_a_across_r7 {
    ($input:expr, $store:expr) => {{
        $input
            .iter()
            .map(|(_, z)| {
                let from = $store.drawing.exhume_from(&z.from).unwrap();
                (&from.id, from)
            })
            .collect::<Vec<(&Uuid, &Anchor)>>()
    }};
}

/// Macro to traverse Anchor ➡ BinaryUI, via R7
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &Anchor)>`, and returns a `Vec<(&Uuid, &BinaryUI)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_bui_across_r7 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.drawing.iter_binary_ui() {
                if z.from == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }};
}
