//! Macros for navigation the Drawing domain
//!
//! Generated Code -- do not edit
//! Use the following invocation to reproduce.
//! ```ignore
//!  target/debug/gen_macro_drawing models/sarzak.json src/sarzak/macros.rs
//! ```

/// Macro to traverse Supertype ➡ Object, via R14
///
/// This macro expects an `impl Iterator<Item=(&Uuid, &Supertype)>`, and returns a `Vec<(&Uuid, &Object)>`.
///
/// Generated by `generate_binary_macro_referrer_to_referent`
#[macro_export]
macro_rules! get_obj_across_r14 {
    ($input:expr, $store:expr) => {{
        use nut::sarzak::Object;
        $input
            .iter()
            .map(|(_,z)| {
                let obj_id = $store.sarzak.exhume_object(&z.obj_id).unwrap();
                 (&obj_id.id, obj_id)
            })
            .collect::<Vec<(&Uuid, &Object)>>()
    }}
}


/// Macro to traverse Object ➡ Supertype, via R14
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &Object)>`, and returns a `Vec<(&Uuid, &Supertype)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_r_sup_across_r14 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.sarzak.iter_supertype() {
                if z.obj_id == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }}
}


/// Macro to traverse Referrer ➡ Cardinality, via R9
///
/// This macro expects an `impl Iterator<Item=(&Uuid, &Referrer)>`, and returns a `Vec<(&Uuid, &Cardinality)>`.
///
/// Generated by `generate_binary_macro_referrer_to_referent`
#[macro_export]
macro_rules! get_card_across_r9 {
    ($input:expr, $store:expr) => {{
        use nut::sarzak::Cardinality;
        $input
            .iter()
            .map(|(_,z)| {
                let cardinality = $store.sarzak.exhume_cardinality(&z.cardinality).unwrap();
                 (&cardinality.id, cardinality)
            })
            .collect::<Vec<(&Uuid, &Cardinality)>>()
    }}
}


/// Macro to traverse Cardinality ➡ Referrer, via R9
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &Cardinality)>`, and returns a `Vec<(&Uuid, &Referrer)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_r_from_across_r9 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.sarzak.iter_referrer() {
                if z.cardinality == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }}
}


/// Macro to traverse Binary ➡ Referent, via R5
///
/// This macro expects an `impl Iterator<Item=(&Uuid, &Binary)>`, and returns a `Vec<(&Uuid, &Referent)>`.
///
/// Generated by `generate_binary_macro_referrer_to_referent`
#[macro_export]
macro_rules! get_r_to_across_r5 {
    ($input:expr, $store:expr) => {{
        use nut::sarzak::Referent;
        $input
            .iter()
            .map(|(_,z)| {
                let to = $store.sarzak.exhume_referent(&z.to).unwrap();
                 (&to.id, to)
            })
            .collect::<Vec<(&Uuid, &Referent)>>()
    }}
}


/// Macro to traverse Referent ➡ Binary, via R5
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &Referent)>`, and returns a `Vec<(&Uuid, &Binary)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_r_bin_across_r5 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.sarzak.iter_binary() {
                if z.to == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }}
}


/// Macro to traverse Subtype ➡ Object, via R15
///
/// This macro expects an `impl Iterator<Item=(&Uuid, &Subtype)>`, and returns a `Vec<(&Uuid, &Object)>`.
///
/// Generated by `generate_binary_macro_referrer_to_referent`
#[macro_export]
macro_rules! get_obj_across_r15 {
    ($input:expr, $store:expr) => {{
        use nut::sarzak::Object;
        $input
            .iter()
            .map(|(_,z)| {
                let obj_id = $store.sarzak.exhume_object(&z.obj_id).unwrap();
                 (&obj_id.id, obj_id)
            })
            .collect::<Vec<(&Uuid, &Object)>>()
    }}
}


/// Macro to traverse Object ➡ Subtype, via R15
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &Object)>`, and returns a `Vec<(&Uuid, &Subtype)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_r_sub_across_r15 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.sarzak.iter_subtype() {
                if z.obj_id == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }}
}


/// Macro to traverse Binary ➡ Referrer, via R6
///
/// This macro expects an `impl Iterator<Item=(&Uuid, &Binary)>`, and returns a `Vec<(&Uuid, &Referrer)>`.
///
/// Generated by `generate_binary_macro_referrer_to_referent`
#[macro_export]
macro_rules! get_r_from_across_r6 {
    ($input:expr, $store:expr) => {{
        use nut::sarzak::Referrer;
        $input
            .iter()
            .map(|(_,z)| {
                let from = $store.sarzak.exhume_referrer(&z.from).unwrap();
                 (&from.id, from)
            })
            .collect::<Vec<(&Uuid, &Referrer)>>()
    }}
}


/// Macro to traverse Referrer ➡ Binary, via R6
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &Referrer)>`, and returns a `Vec<(&Uuid, &Binary)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_r_bin_across_r6 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.sarzak.iter_binary() {
                if z.from == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }}
}


/// Macro to traverse Referent ➡ Conditionality, via R12
///
/// This macro expects an `impl Iterator<Item=(&Uuid, &Referent)>`, and returns a `Vec<(&Uuid, &Conditionality)>`.
///
/// Generated by `generate_binary_macro_referrer_to_referent`
#[macro_export]
macro_rules! get_cond_across_r12 {
    ($input:expr, $store:expr) => {{
        use nut::sarzak::Conditionality;
        $input
            .iter()
            .map(|(_,z)| {
                let conditionality = $store.sarzak.exhume_conditionality(&z.conditionality).unwrap();
                 (&conditionality.id, conditionality)
            })
            .collect::<Vec<(&Uuid, &Conditionality)>>()
    }}
}


/// Macro to traverse Conditionality ➡ Referent, via R12
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &Conditionality)>`, and returns a `Vec<(&Uuid, &Referent)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_r_to_across_r12 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.sarzak.iter_referent() {
                if z.conditionality == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }}
}


/// Macro to traverse Event ➡ State, via R20
///
/// This macro expects an `impl Iterator<Item=(&Uuid, &Event)>`, and returns a `Vec<(&Uuid, &State)>`.
///
/// Generated by `generate_binary_macro_referrer_to_referent`
#[macro_export]
macro_rules! get_s_across_r20 {
    ($input:expr, $store:expr) => {{
        use nut::sarzak::State;
        $input
            .iter()
            .map(|(_,z)| {
                let state_id = $store.sarzak.exhume_state(&z.state_id).unwrap();
                 (&state_id.id, state_id)
            })
            .collect::<Vec<(&Uuid, &State)>>()
    }}
}


/// Macro to traverse State ➡ Event, via R20
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &State)>`, and returns a `Vec<(&Uuid, &Event)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_e_across_r20 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.sarzak.iter_event() {
                if z.state_id == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }}
}


/// Macro to traverse Referrer ➡ Object, via R17
///
/// This macro expects an `impl Iterator<Item=(&Uuid, &Referrer)>`, and returns a `Vec<(&Uuid, &Object)>`.
///
/// Generated by `generate_binary_macro_referrer_to_referent`
#[macro_export]
macro_rules! get_obj_across_r17 {
    ($input:expr, $store:expr) => {{
        use nut::sarzak::Object;
        $input
            .iter()
            .map(|(_,z)| {
                let obj_id = $store.sarzak.exhume_object(&z.obj_id).unwrap();
                 (&obj_id.id, obj_id)
            })
            .collect::<Vec<(&Uuid, &Object)>>()
    }}
}


/// Macro to traverse Object ➡ Referrer, via R17
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &Object)>`, and returns a `Vec<(&Uuid, &Referrer)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_r_from_across_r17 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.sarzak.iter_referrer() {
                if z.obj_id == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }}
}


/// Macro to traverse Referent ➡ Cardinality, via R8
///
/// This macro expects an `impl Iterator<Item=(&Uuid, &Referent)>`, and returns a `Vec<(&Uuid, &Cardinality)>`.
///
/// Generated by `generate_binary_macro_referrer_to_referent`
#[macro_export]
macro_rules! get_card_across_r8 {
    ($input:expr, $store:expr) => {{
        use nut::sarzak::Cardinality;
        $input
            .iter()
            .map(|(_,z)| {
                let cardinality = $store.sarzak.exhume_cardinality(&z.cardinality).unwrap();
                 (&cardinality.id, cardinality)
            })
            .collect::<Vec<(&Uuid, &Cardinality)>>()
    }}
}


/// Macro to traverse Cardinality ➡ Referent, via R8
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &Cardinality)>`, and returns a `Vec<(&Uuid, &Referent)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_r_to_across_r8 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.sarzak.iter_referent() {
                if z.cardinality == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }}
}


/// Macro to traverse State ➡ Object, via R18
///
/// This macro expects an `impl Iterator<Item=(&Uuid, &State)>`, and returns a `Vec<(&Uuid, &Object)>`.
///
/// Generated by `generate_binary_macro_referrer_to_referent`
#[macro_export]
macro_rules! get_obj_across_r18 {
    ($input:expr, $store:expr) => {{
        use nut::sarzak::Object;
        $input
            .iter()
            .map(|(_,z)| {
                let obj_id = $store.sarzak.exhume_object(&z.obj_id).unwrap();
                 (&obj_id.id, obj_id)
            })
            .collect::<Vec<(&Uuid, &Object)>>()
    }}
}


/// Macro to traverse Object ➡ State, via R18
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &Object)>`, and returns a `Vec<(&Uuid, &State)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_s_across_r18 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.sarzak.iter_state() {
                if z.obj_id == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }}
}


/// Macro to traverse Attribute ➡ Object, via R1
///
/// This macro expects an `impl Iterator<Item=(&Uuid, &Attribute)>`, and returns a `Vec<(&Uuid, &Object)>`.
///
/// Generated by `generate_binary_macro_referrer_to_referent`
#[macro_export]
macro_rules! get_obj_across_r1 {
    ($input:expr, $store:expr) => {{
        use nut::sarzak::Object;
        $input
            .iter()
            .map(|(_,z)| {
                let obj_id = $store.sarzak.exhume_object(&z.obj_id).unwrap();
                 (&obj_id.id, obj_id)
            })
            .collect::<Vec<(&Uuid, &Object)>>()
    }}
}


/// Macro to traverse Object ➡ Attribute, via R1
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &Object)>`, and returns a `Vec<(&Uuid, &Attribute)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_a_across_r1 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.sarzak.iter_attribute() {
                if z.obj_id == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }}
}


/// Macro to traverse Event ➡ Object, via R19
///
/// This macro expects an `impl Iterator<Item=(&Uuid, &Event)>`, and returns a `Vec<(&Uuid, &Object)>`.
///
/// Generated by `generate_binary_macro_referrer_to_referent`
#[macro_export]
macro_rules! get_obj_across_r19 {
    ($input:expr, $store:expr) => {{
        use nut::sarzak::Object;
        $input
            .iter()
            .map(|(_,z)| {
                let obj_id = $store.sarzak.exhume_object(&z.obj_id).unwrap();
                 (&obj_id.id, obj_id)
            })
            .collect::<Vec<(&Uuid, &Object)>>()
    }}
}


/// Macro to traverse Object ➡ Event, via R19
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &Object)>`, and returns a `Vec<(&Uuid, &Event)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_e_across_r19 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.sarzak.iter_event() {
                if z.obj_id == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }}
}


/// Macro to traverse Attribute ➡ Type, via R2
///
/// This macro expects an `impl Iterator<Item=(&Uuid, &Attribute)>`, and returns a `Vec<(&Uuid, &Type)>`.
///
/// Generated by `generate_binary_macro_referrer_to_referent`
#[macro_export]
macro_rules! get_t_across_r2 {
    ($input:expr, $store:expr) => {{
        use nut::sarzak::Type;
        $input
            .iter()
            .map(|(_,z)| {
                let r#type = $store.sarzak.exhume_type(&z.r#type).unwrap();
                 (&r#type.id, r#type)
            })
            .collect::<Vec<(&Uuid, &Type)>>()
    }}
}


/// Macro to traverse Type ➡ Attribute, via R2
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &Type)>`, and returns a `Vec<(&Uuid, &Attribute)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_a_across_r2 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.sarzak.iter_attribute() {
                if z.r#type == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }}
}


/// Macro to traverse Referrer ➡ Conditionality, via R11
///
/// This macro expects an `impl Iterator<Item=(&Uuid, &Referrer)>`, and returns a `Vec<(&Uuid, &Conditionality)>`.
///
/// Generated by `generate_binary_macro_referrer_to_referent`
#[macro_export]
macro_rules! get_cond_across_r11 {
    ($input:expr, $store:expr) => {{
        use nut::sarzak::Conditionality;
        $input
            .iter()
            .map(|(_,z)| {
                let conditionality = $store.sarzak.exhume_conditionality(&z.conditionality).unwrap();
                 (&conditionality.id, conditionality)
            })
            .collect::<Vec<(&Uuid, &Conditionality)>>()
    }}
}


/// Macro to traverse Conditionality ➡ Referrer, via R11
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &Conditionality)>`, and returns a `Vec<(&Uuid, &Referrer)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_r_from_across_r11 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.sarzak.iter_referrer() {
                if z.conditionality == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }}
}


/// Macro to traverse Referent ➡ Object, via R16
///
/// This macro expects an `impl Iterator<Item=(&Uuid, &Referent)>`, and returns a `Vec<(&Uuid, &Object)>`.
///
/// Generated by `generate_binary_macro_referrer_to_referent`
#[macro_export]
macro_rules! get_obj_across_r16 {
    ($input:expr, $store:expr) => {{
        use nut::sarzak::Object;
        $input
            .iter()
            .map(|(_,z)| {
                let obj_id = $store.sarzak.exhume_object(&z.obj_id).unwrap();
                 (&obj_id.id, obj_id)
            })
            .collect::<Vec<(&Uuid, &Object)>>()
    }}
}


/// Macro to traverse Object ➡ Referent, via R16
///
/// This macro expects a `impl Iterator<Item=(&Uuid, &Object)>`, and returns a `Vec<(&Uuid, &Referent)>`.
///
/// Generated by `generate_binary_macro_referent_to_referrer`
#[macro_export]
macro_rules! get_r_to_across_r16 {
    ($input:expr, $store:expr) => {{
        let mut result = Vec::new();
        for (id, i) in &$input {
            for (z_id, z) in $store.sarzak.iter_referent() {
                if z.obj_id == **id {
                    result.push((z_id, z));
                }
            }
        }
        result
    }}
}

