//! Macros for navigating the "One To Many" domain
//!
//! # Generated Code -- edit _with care_.
//!
//! Don't mess with anything between `{"magic":"îž¨","kind":"CriticalBlockBegin"}`
//! and `{"magic":"îž¨","kind":"CriticalBlockEnd"}`. Otherwise, you should be free
//! to go wild. Happy hacking!
//!
//! Use the following invocation to reproduce:
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
//! ```shell
//!  /Users/uberfoo/projects/sarzak/nut/target/debug/deps/generate_test_domain-145fdb9ab1f4b4be --nocapture
//! ```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
// {"magic":"îž¨","version":"0.2.0"}
// {"magic":"îž¨","version":"0.5.0"}
// {"magic":"îž¨","version":"1.0.0"}

/// Macro to traverse [`A`][ðŸ¦€] âž¡ [`Referent`][ðŸ¦ž], via _R1_
///
/// This macro expects a &[`A`][ðŸ¦€], and returns a &[`Referent`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::one_to_many::types::A
/// [ðŸ¦ž]: crate::one_to_many::types::Referent
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use test_models::one_to_many::Referent;
/// # use test_models::one_to_many::A;
/// # use test_models::one_to_many_get_one_tgt_across_r1;
/// # let mut store = test_models::one_to_many::ObjectStore::new();
///
/// let profuse_sneeze = "fertile_route".to_owned();
/// let referent_mmk = Referent::new(&mut store, profuse_sneeze);
/// let fluttering_value = "voracious_beggar".to_owned();
///
/// let a = A::new(&mut store, &referent_mmk, fluttering_value);
///
/// let referent_aob = one_to_many_get_one_tgt_across_r1!(a, store);
/// assert_eq!(&referent_mmk, referent_aob);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"one_to_many_get_many_tgts_across_r1-emit_binary_main"}}}
macro_rules! one_to_many_get_many_tgts_across_r1 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"referent-emit_many_unconditional"}}}
        // nut::codegen::template::macros::emit_many_unconditional
        let mut result = Vec::new();
        for z in &$input.ptr {
            let ptr = $store.exhume_referent(&z).unwrap();
            result.push(ptr);
        }
        result
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"referent-emit_many_unconditional"}}}
    }};
}
pub use one_to_many_get_one_tgt_across_r1;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"one_to_many_get_one_tgt_across_r1-emit_binary_main"}}}
pub use one_to_many_get_many_tgts_across_r1;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"one_to_many_get_many_tgts_across_r1-emit_binary_main"}}}

/// Macro to traverse [`Referent`][ðŸ¦€] âž¡ [`A`][ðŸ¦ž], via _R1_
///
/// This macro expects a &[`Referent`][ðŸ¦€], and returns a &[`A`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::one_to_many::types::Referent
/// [ðŸ¦ž]: crate::one_to_many::types::A
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use test_models::one_to_many::A;
/// # use test_models::one_to_many::Referent;
/// # use test_models::one_to_many_get_many_as_across_r1;
/// # let mut store = test_models::one_to_many::ObjectStore::new();
///
/// let needy_hill = "foolish_clocks".to_owned();
/// let referent_anv = Referent::new(&mut store, needy_hill);
/// let smelly_fang = "elated_arch".to_owned();
///
/// let a = A::new(&mut store, &referent_anv, smelly_fang);
/// let a_kil = one_to_many_get_many_as_across_r1!(referent_anv, store);
///
/// assert!(a_kil.iter().find(|&x| **x == a).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"one_to_many_get_one_a_across_r1-emit_binary_main"}}}
macro_rules! one_to_many_get_one_a_across_r1 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"referent-a-emit_one_unconditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_a()
            .find(|z| z.1.ptr == $input.id)
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"referent-a-emit_one_unconditional_lookup"}}}
    }};
}
pub use one_to_many_get_many_as_across_r1;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"one_to_many_get_many_as_across_r1-emit_binary_main"}}}
pub use one_to_many_get_one_a_across_r1;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"one_to_many_get_one_a_across_r1-emit_binary_main"}}}

/// Macro to traverse [`B`][ðŸ¦€] âž¡ [`Referent`][ðŸ¦ž], via _R2(c)_
/// Macro to traverse [`B`][ðŸ¦€] âž¡ [`Referent`][ðŸ¦ž], via _R2_
///
/// This macro expects a &[`B`][ðŸ¦€], and returns an Option<&[`Referent`][ðŸ¦ž]>.
/// This macro expects a &[`B`][ðŸ¦€], and returns a &[`Referent`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::one_to_many::types::B
/// [ðŸ¦ž]: crate::one_to_many::types::Referent
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use test_models::one_to_many::Referent;
/// # use test_models::one_to_many::B;
/// # use test_models::one_to_many_maybe_get_one_tgt_across_r2;
/// # let mut store = test_models::one_to_many::ObjectStore::new();
///
/// let tame_motion = "goofy_veil".to_owned();
/// let referent = Referent::new(&mut store, tame_motion);
/// let exotic_lawyer = "super_bears".to_owned();
/// let maddening_organization = "six_spade".to_owned();
///
/// let b = B::new(&mut store, Some(&referent), exotic_lawyer);
///
/// let referent_hik = one_to_many_maybe_get_one_tgt_across_r2!(b, store);
/// assert_eq!(Some(&referent), referent_hik);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"one_to_many_get_many_tgts_across_r2-emit_binary_main"}}}
macro_rules! one_to_many_get_many_tgts_across_r2 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"referent-emit_many_unconditional"}}}
        // nut::codegen::template::macros::emit_many_unconditional
        let mut result = Vec::new();
        for z in &$input.ptr {
            let ptr = $store.exhume_referent(&z).unwrap();
            result.push(ptr);
        }
        result
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"referent-emit_many_unconditional"}}}
    }};
}
pub use one_to_many_maybe_get_one_tgt_across_r2;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"one_to_many_maybe_get_one_tgt_across_r2-emit_binary_main"}}}
pub use one_to_many_get_many_tgts_across_r2;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"one_to_many_get_many_tgts_across_r2-emit_binary_main"}}}

/// Macro to traverse [`Referent`][ðŸ¦€] âž¡ [`B`][ðŸ¦ž], via _R2_
/// Macro to traverse [`Referent`][ðŸ¦€] âž¡ [`B`][ðŸ¦ž], via _R2(c)_
///
/// This macro expects a &[`Referent`][ðŸ¦€], and returns a &[`B`][ðŸ¦ž].
/// This macro expects a &[`Referent`][ðŸ¦€], and returns an Option<&[`B`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::one_to_many::types::Referent
/// [ðŸ¦ž]: crate::one_to_many::types::B
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use test_models::one_to_many::B;
/// # use test_models::one_to_many::Referent;
/// # use test_models::one_to_many_get_many_bs_across_r2;
/// # let mut store = test_models::one_to_many::ObjectStore::new();
///
/// let undesirable_card = "wandering_growth".to_owned();
/// let endurable_treatment = "colossal_hour".to_owned();
/// let referent = Referent::new(&mut store, endurable_treatment);
/// let brown_hat = "wealthy_salt".to_owned();
///
/// let b = B::new(&mut store, Some(&referent), brown_hat);
///
/// let b_zje = one_to_many_get_many_bs_across_r2!(referent, store);
/// assert!(b_zje.iter().find(|&x| **x == b).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"one_to_many_maybe_get_one_b_across_r2-emit_binary_main"}}}
macro_rules! one_to_many_maybe_get_one_b_across_r2 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"referent-b-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_b()
            .find(|z| z.1.ptr == $input.id)
            .map(|(_, z)| z)
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"referent-b-emit_one_conditional_lookup"}}}
    }};
}
pub use one_to_many_get_many_bs_across_r2;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"one_to_many_get_many_bs_across_r2-emit_binary_main"}}}
pub use one_to_many_maybe_get_one_b_across_r2;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"one_to_many_maybe_get_one_b_across_r2-emit_binary_main"}}}

/// Macro to traverse [`C`][ðŸ¦€] âž¡ [`Referent`][ðŸ¦ž], via _R3_
/// Macro to traverse [`C`][ðŸ¦€] âž¡ [`Referent`][ðŸ¦ž], via _R3(c)_
///
/// This macro expects a &[`C`][ðŸ¦€], and returns a &[`Referent`][ðŸ¦ž].
/// This macro expects a &[`C`][ðŸ¦€], and returns an Option<&[`Referent`][ðŸ¦ž]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [ðŸ¦€]: crate::one_to_many::types::C
/// [ðŸ¦ž]: crate::one_to_many::types::Referent
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use test_models::one_to_many::C;
/// # use test_models::one_to_many::Referent;
/// # use test_models::one_to_many_get_one_tgt_across_r3;
/// # let mut store = test_models::one_to_many::ObjectStore::new();
///
/// let righteous_throat = "petite_thumb".to_owned();
/// let referent_ttx = Referent::new(&mut store, righteous_throat);
///
/// let c = C::new(&mut store, &referent_ttx, 42.0);
///
/// let referent_hfx = one_to_many_get_one_tgt_across_r3!(c, store);
/// assert_eq!(&referent_ttx, referent_hfx);
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"one_to_many_maybe_get_many_tgts_across_r3-emit_binary_main"}}}
macro_rules! one_to_many_maybe_get_many_tgts_across_r3 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"referent-emit_many_unconditional"}}}
        // nut::codegen::template::macros::emit_many_unconditional
        let mut result = Vec::new();
        for z in &$input.ptr {
            let ptr = $store.exhume_referent(&z).unwrap();
            result.push(ptr);
        }
        result
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"referent-emit_many_unconditional"}}}
    }};
}
pub use one_to_many_get_one_tgt_across_r3;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"one_to_many_get_one_tgt_across_r3-emit_binary_main"}}}
pub use one_to_many_maybe_get_many_tgts_across_r3;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"one_to_many_maybe_get_many_tgts_across_r3-emit_binary_main"}}}

/// Macro to traverse [`Referent`][ðŸ¦€] âž¡ [`C`][ðŸ¦ž], via _R3(c)_
/// Macro to traverse [`Referent`][ðŸ¦€] âž¡ [`C`][ðŸ¦ž], via _R3_
///
/// This macro expects a &[`Referent`][ðŸ¦€], and returns an Option<&[`C`][ðŸ¦ž]>.
/// This macro expects a &[`Referent`][ðŸ¦€], and returns a &[`C`][ðŸ¦ž].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [ðŸ¦€]: crate::one_to_many::types::Referent
/// [ðŸ¦ž]: crate::one_to_many::types::C
// {"magic":"îž¨","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use test_models::one_to_many::Referent;
/// # use test_models::one_to_many::C;
/// # use test_models::one_to_many_maybe_get_many_cs_across_r3;
/// # let mut store = test_models::one_to_many::ObjectStore::new();
///
/// let full_aftermath = "giant_juice".to_owned();
/// let referent_hzl = Referent::new(&mut store, full_aftermath);
///
/// let c = C::new(&mut store, &referent_hzl, 42.0);
/// let c_jdz = one_to_many_maybe_get_many_cs_across_r3!(referent_hzl, store);
///
/// assert!(c_jdz.iter().find(|&x| **x == c).is_some());
///```
// {"magic":"îž¨","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"one_to_many_get_one_c_across_r3-emit_binary_main"}}}
macro_rules! one_to_many_get_one_c_across_r3 {
    ($input:expr, $store:expr) => {{
        // {"magic":"îž¨","kind":{"CriticalBlockBegin":{"tag":"referent-c-emit_one_unconditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_c()
            .find(|z| z.1.ptr == $input.id)
            .map(|z| z.1)
            .unwrap()
        // {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"referent-c-emit_one_unconditional_lookup"}}}
    }};
}
pub use one_to_many_maybe_get_many_cs_across_r3;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"one_to_many_maybe_get_many_cs_across_r3-emit_binary_main"}}}
pub use one_to_many_get_one_c_across_r3;
// {"magic":"îž¨","kind":{"CriticalBlockEnd":{"tag":"one_to_many_get_one_c_across_r3-emit_binary_main"}}}
