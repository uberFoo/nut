//! Macros for navigating the "One To One" domain
//!
//! # Generated Code -- edit _with care_.
//!
//! Don't mess with anything between `{"magic":"","kind":"CriticalBlockBegin"}`
//! and `{"magic":"","kind":"CriticalBlockEnd"}`. Otherwise, you should be free
//! to go wild. Happy hacking!
//!
//! Use the following invocation to reproduce:
// {"magic":"","kind":{"IgnoreBlockBegin":{}}}
//! ```shell
//!  /Users/uberfoo/projects/sarzak/nut/target/debug/deps/generate_test_domain-145fdb9ab1f4b4be --nocapture
//! ```
// {"magic":"","kind":"IgnoreBlockEnd"}
// {"magic":"","version":"0.2.0"}
// {"magic":"","version":"0.5.0"}
// {"magic":"","version":"1.0.0"}

/// Macro to traverse [`A`][🦀] ➡ [`Referent`][🦞], via _R1_
/// Macro to traverse [`A`][🦀] ➡ [`Referent`][🦞], via _R1(c)_
///
/// This macro expects a &[`A`][🦀], and returns a &[`Referent`][🦞].
/// This macro expects a &[`A`][🦀], and returns an Option<&[`Referent`][🦞]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [🦀]: crate::one_to_one::types::A
/// [🦞]: crate::one_to_one::types::Referent
// {"magic":"","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use test_models::one_to_one::Referent;
/// # use test_models::one_to_one::A;
/// # use test_models::one_to_one_get_one_tgt_across_r1;
/// # let mut store = test_models::one_to_one::ObjectStore::new();
///
/// let energetic_expansion = "cooperative_mark".to_owned();
/// let referent_yvk = Referent::new(&mut store, energetic_expansion);
///
/// let a = A::new(&mut store, &referent_yvk, 42);
///
/// let referent_yqb = one_to_one_get_one_tgt_across_r1!(a, store);
/// assert_eq!(&referent_yvk, referent_yqb);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"","kind":{"CriticalBlockBegin":{"tag":"one_to_one_maybe_get_one_tgt_across_r1-emit_binary_main"}}}
macro_rules! one_to_one_maybe_get_one_tgt_across_r1 {
    ($input:expr, $store:expr) => {{
        // {"magic":"","kind":{"CriticalBlockBegin":{"tag":"referent-emit_one_conditional"}}}
        // nut::codegen::template::macros::emit_one_conditional
        match &$input.ptr {
            Some(i) => $store.exhume_referent(i),
            None => None,
        }
        // {"magic":"","kind":{"CriticalBlockEnd":{"tag":"referent-emit_one_conditional"}}}
    }};
}
pub use one_to_one_maybe_get_one_tgt_across_r1;
// {"magic":"","kind":{"CriticalBlockEnd":{"tag":"one_to_one_maybe_get_one_tgt_across_r1-emit_binary_main"}}}

/// Macro to traverse [`Referent`][🦀] ➡ [`A`][🦞], via _R1(c)_
/// Macro to traverse [`Referent`][🦀] ➡ [`A`][🦞], via _R1_
///
/// This macro expects a &[`Referent`][🦀], and returns an Option<&[`A`][🦞]>.
/// This macro expects a &[`Referent`][🦀], and returns a &[`A`][🦞].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [🦀]: crate::one_to_one::types::Referent
/// [🦞]: crate::one_to_one::types::A
// {"magic":"","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use test_models::one_to_one::A;
/// # use test_models::one_to_one::Referent;
/// # use test_models::one_to_one_maybe_get_one_a_across_r1;
/// # let mut store = test_models::one_to_one::ObjectStore::new();
///
/// let utter_dinner = "messy_bridge".to_owned();
/// let referent_tmg = Referent::new(&mut store, utter_dinner);
///
/// let a = A::new(&mut store, &referent_tmg, 42);
/// let a_aff = one_to_one_maybe_get_one_a_across_r1!(referent_tmg, store);
///
/// assert_eq!(Some(&a), a_aff);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"","kind":{"CriticalBlockBegin":{"tag":"one_to_one_get_one_a_across_r1-emit_binary_main"}}}
macro_rules! one_to_one_get_one_a_across_r1 {
    ($input:expr, $store:expr) => {{
        // {"magic":"","kind":{"CriticalBlockBegin":{"tag":"referent-a-emit_one_unconditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_a()
            .find(|z| z.1.ptr == $input.id)
            .map(|z| z.1)
            .unwrap()
        // {"magic":"","kind":{"CriticalBlockEnd":{"tag":"referent-a-emit_one_unconditional_lookup"}}}
    }};
}
pub use one_to_one_maybe_get_one_a_across_r1;
// {"magic":"","kind":{"CriticalBlockEnd":{"tag":"one_to_one_maybe_get_one_a_across_r1-emit_binary_main"}}}
pub use one_to_one_get_one_a_across_r1;
// {"magic":"","kind":{"CriticalBlockEnd":{"tag":"one_to_one_get_one_a_across_r1-emit_binary_main"}}}

/// Macro to traverse [`B`][🦀] ➡ [`Referent`][🦞], via _R2_
///
/// This macro expects a &[`B`][🦀], and returns a &[`Referent`][🦞].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [🦀]: crate::one_to_one::types::B
/// [🦞]: crate::one_to_one::types::Referent
// {"magic":"","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use test_models::one_to_one::B;
/// # use test_models::one_to_one::Referent;
/// # use test_models::one_to_one_get_one_tgt_across_r2;
/// # let mut store = test_models::one_to_one::ObjectStore::new();
///
/// let reflective_crate = "oafish_order".to_owned();
/// let referent_tox = Referent::new(&mut store, reflective_crate);
///
/// let b = B::new(&mut store, &referent_tox, true);
///
/// let referent_nrf = one_to_one_get_one_tgt_across_r2!(b, store);
/// assert_eq!(&referent_tox, referent_nrf);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"","kind":{"CriticalBlockBegin":{"tag":"one_to_one_get_one_tgt_across_r2-emit_binary_main"}}}
macro_rules! one_to_one_get_one_tgt_across_r2 {
    ($input:expr, $store:expr) => {{
        // {"magic":"","kind":{"CriticalBlockBegin":{"tag":"referent-emit_one_unconditional"}}}
        // nut::codegen::template::macros::emit_one_unconditional
        $store.exhume_referent(&$input.ptr).unwrap()
        // {"magic":"","kind":{"CriticalBlockEnd":{"tag":"referent-emit_one_unconditional"}}}
    }};
}
pub use one_to_one_get_one_tgt_across_r2;
// {"magic":"","kind":{"CriticalBlockEnd":{"tag":"one_to_one_get_one_tgt_across_r2-emit_binary_main"}}}

/// Macro to traverse [`Referent`][🦀] ➡ [`B`][🦞], via _R2_
///
/// This macro expects a &[`Referent`][🦀], and returns a &[`B`][🦞].
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [🦀]: crate::one_to_one::types::Referent
/// [🦞]: crate::one_to_one::types::B
// {"magic":"","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use test_models::one_to_one::B;
/// # use test_models::one_to_one::Referent;
/// # use test_models::one_to_one_get_one_b_across_r2;
/// # let mut store = test_models::one_to_one::ObjectStore::new();
///
/// let wide_sort = "festive_guide".to_owned();
/// let referent_nyn = Referent::new(&mut store, wide_sort);
///
/// let b = B::new(&mut store, &referent_nyn, true);
/// let b_jbq = one_to_one_get_one_b_across_r2!(referent_nyn, store);
///
/// assert_eq!(&b, b_jbq);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"","kind":{"CriticalBlockBegin":{"tag":"one_to_one_get_one_b_across_r2-emit_binary_main"}}}
macro_rules! one_to_one_get_one_b_across_r2 {
    ($input:expr, $store:expr) => {{
//         // {"magic":"","kind":"CriticalBlockBegin"} //⚡️
//         // {"magic":"","kind":{"CriticalBlockBegin":"referent-b-emit_one_unconditional_lookup"}} //⚡️
        // {"magic":"","kind":{"CriticalBlockBegin":{"tag":"referent-b-emit_one_unconditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_unconditional_lookup
        $store
            .iter_b()
            .find(|z| z.1.ptr == $input.id)
            .map(|z| z.1)
            .unwrap()
// ⚡️         // {"magic":"","kind":"CriticalBlockEnd"}
// ⚡️         // {"magic":"","kind":{"CriticalBlockEnd":"referent-b-emit_one_unconditional_lookup"}}
//             // {"magic":"","kind":{"CriticalBlockEnd":{"tag":"referent-b-emit_one_unconditional_lookup"}}} //⚡️
        // {"magic":"","kind":{"CriticalBlockEnd":{"tag":"referent-b-emit_one_unconditional_lookup"}}}
    }};
}
pub use one_to_one_get_one_b_across_r2;
// {"magic":"","kind":{"CriticalBlockEnd":{"tag":"one_to_one_get_one_b_across_r2-emit_binary_main"}}}

/// Macro to traverse [`C`][🦀] ➡ [`Referent`][🦞], via _R3(c)_
///
/// This macro expects a &[`C`][🦀], and returns an Option<&[`Referent`][🦞]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referrer_to_referent_imp`
///
/// [🦀]: crate::one_to_one::types::C
/// [🦞]: crate::one_to_one::types::Referent
// {"magic":"","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use test_models::one_to_one::Referent;
/// # use test_models::one_to_one::C;
/// # use test_models::one_to_one_maybe_get_one_tgt_across_r3;
/// # let mut store = test_models::one_to_one::ObjectStore::new();
///
/// let short_flesh = "pale_jump".to_owned();
/// let referent = Referent::new(&mut store, short_flesh);
/// let well_groomed_moon = "brainy_recess".to_owned();
///
/// let c = C::new(&mut store, Some(&referent), 42.0);
///
/// let referent_ujg = one_to_one_maybe_get_one_tgt_across_r3!(c, store);
/// assert_eq!(Some(&referent), referent_ujg);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"","kind":{"CriticalBlockBegin":{"tag":"one_to_one_maybe_get_one_tgt_across_r3-emit_binary_main"}}}
macro_rules! one_to_one_maybe_get_one_tgt_across_r3 {
    ($input:expr, $store:expr) => {{
        // {"magic":"","kind":{"CriticalBlockBegin":{"tag":"referent-emit_one_conditional"}}}
        // nut::codegen::template::macros::emit_one_conditional
        match &$input.ptr {
            Some(i) => $store.exhume_referent(i),
            None => None,
        }
        // {"magic":"","kind":{"CriticalBlockEnd":{"tag":"referent-emit_one_conditional"}}}
    }};
}
pub use one_to_one_maybe_get_one_tgt_across_r3;
// {"magic":"","kind":{"CriticalBlockEnd":{"tag":"one_to_one_maybe_get_one_tgt_across_r3-emit_binary_main"}}}

/// Macro to traverse [`Referent`][🦀] ➡ [`C`][🦞], via _R3(c)_
///
/// This macro expects a &[`Referent`][🦀], and returns an Option<&[`C`][🦞]>.
///
/// Generated by `nut::domain::generate_macros::generate_binary_macro_referent_to_referrer_imp`
///
/// [🦀]: crate::one_to_one::types::Referent
/// [🦞]: crate::one_to_one::types::C
// {"magic":"","kind":{"IgnoreBlockBegin":{}}}
///
/// # Example
///
///```
/// # use test_models::one_to_one::C;
/// # use test_models::one_to_one::Referent;
/// # use test_models::one_to_one_maybe_get_one_c_across_r3;
/// # let mut store = test_models::one_to_one::ObjectStore::new();
///
/// let straight_letters = "bumpy_balls".to_owned();
/// let aware_kitty = "tacky_flower".to_owned();
/// let referent = Referent::new(&mut store, aware_kitty);
///
/// let c = C::new(&mut store, Some(&referent), 42.0);
///
/// let c_ojd = one_to_one_maybe_get_one_c_across_r3!(referent, store);
/// assert_eq!(Some(&c), c_ojd);
///```
// {"magic":"","kind":"IgnoreBlockEnd"}
#[macro_export]
// {"magic":"","kind":{"CriticalBlockBegin":{"tag":"one_to_one_maybe_get_one_c_across_r3-emit_binary_main"}}}
macro_rules! one_to_one_maybe_get_one_c_across_r3 {
    ($input:expr, $store:expr) => {{
//         // {"magic":"","kind":"CriticalBlockBegin"} //⚡️
//         // {"magic":"","kind":{"CriticalBlockBegin":"referent-c-emit_one_conditional_lookup"}} //⚡️
        // {"magic":"","kind":{"CriticalBlockBegin":{"tag":"referent-c-emit_one_conditional_lookup"}}}
        // nut::codegen::template::macros::emit_one_conditional_lookup
        $store
            .iter_c()
            .find(|z| z.1.ptr == Some($input.id))
            .map(|(_, z)| z)
// ⚡️         // {"magic":"","kind":"CriticalBlockEnd"}
// ⚡️         // {"magic":"","kind":{"CriticalBlockEnd":"referent-c-emit_one_conditional_lookup"}}
//             // {"magic":"","kind":{"CriticalBlockEnd":{"tag":"referent-c-emit_one_conditional_lookup"}}} //⚡️
        // {"magic":"","kind":{"CriticalBlockEnd":{"tag":"referent-c-emit_one_conditional_lookup"}}}
    }};
}
pub use one_to_one_maybe_get_one_c_across_r3;
// {"magic":"","kind":{"CriticalBlockEnd":{"tag":"one_to_one_maybe_get_one_c_across_r3-emit_binary_main"}}}
